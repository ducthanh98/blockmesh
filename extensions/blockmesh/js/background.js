// A static import is required in b/g scripts because they are executed in their own env
// not connected to the content scripts where wasm is loaded automatically
import initWasmModule, {
  task_poller,
  report_uptime,
  start_websocket,
  measure_bandwidth,
  stop_websocket
} from './wasm/blockmesh_ext.js'

console.log('Background script started')

const PING_INTERVAL = 3 * 1000

// This keeps the service worker alive
function stayAlive() {
  chrome.runtime.sendMessage('ping').then(
    function mute_success() {
    }, function mute_error() {
    }
  )
}

setInterval(() => {
  stayAlive()
  setTimeout(async () => {
    await chrome.storage.local.set({ 'last-stay-alive': new Date().getTime() })
  }, 1000)
}, PING_INTERVAL)

async function create_alarm() {
  try {
    await chrome.alarms.create('stayAlive', {
      delayInMinutes: 0.55
    })
  } catch (e) {
    console.error('Alarm error:', e)
  }
}

chrome.alarms.onAlarm.addListener((alarm) => {
  if (alarm.name === 'stayAlive') {
    create_alarm().then(onSuccess, onError)
  }
})

setInterval(async () => {
  await create_alarm().then(onSuccess, onError)
}, 30_000)


chrome.runtime.onConnect.addListener(async function() {
  console.log('onConnect')
})

chrome.runtime.onStartup.addListener(async function() {
  console.log('onStartup')
})

let polling_interval = 120000
let intervals = []


async function is_ws_feature_connection() {
  try {
    const response1 = await fetch('https://feature-flags.blockmesh.xyz/extension/read-flag/use_websocket')
    if (response1.ok) {
      const value = await response1.text()
      const is_enabled = value === 'true'
      if (!is_enabled) return false
    }
    const response2 = await fetch('https://feature-flags.blockmesh.xyz/extension/read-flag/use_websocket_percent')
    if (response2.ok) {
      const value = await response2.text()
      const percentage = parseInt(value, 10)
      const probe = Math.random() * 100
      return probe < percentage
    }
  } catch (e) {
    console.error('is_ws_feature_connection', e)
    return false
  }
}

async function get_polling_interval() {
  try {
    const response = await fetch('https://feature-flags.blockmesh.xyz/extension/read-flag/polling_interval')
    if (response.ok) {
      const value = await response.text()
      const num = parseFloat(value)
      if (!isNaN(num)) {
        return num
      }
    }
    return 120000
  } catch (_) {
    return 120000
  }
}

function clear_intervals() {
  intervals.forEach(i => clearInterval(i))
}

function recreate_intervals() {
  console.log('Running recreate_intervals')
  clear_intervals()
  try {
    create_alarm().then(onSuccess, onError)
    task_poller().then(onSuccess, onError)
    report_uptime().then(onSuccess, onError)
    measure_bandwidth().then(onSuccess, onError)
  } catch (e) {

  }
  intervals.push(
    setInterval(async () => {
      await create_alarm().then(onSuccess, onError)
      await task_poller().then(onSuccess, onError)
    }, polling_interval + Math.random())
  )
  intervals.push(
    setInterval(async () => {
      await create_alarm().then(onSuccess, onError)
      await report_uptime().then(onSuccess, onError)
    }, polling_interval + Math.random())
  )
  intervals.push(
    setInterval(async () => {
      await create_alarm().then(onSuccess, onError)
      await measure_bandwidth().then(onSuccess, onError)
    }, 10 * polling_interval + Math.random())
  )
}

async function init_background() {
  console.log('init_background')
  // run the wasm initializer before calling wasm methods
  // the initializer is generated by wasm_pack
  await initWasmModule()
  await create_alarm().then(onSuccess, onError)
  await chrome.alarms.create('stayAlive', {
    periodInMinutes: 0.55
  })

  await main_interval()
  setInterval(async () => {
    await main_interval()
  }, polling_interval)
}

async function main_interval() {
  const is_ws_enabled = await is_ws_feature_connection()
  if (is_ws_enabled) {
    console.log('Using WebSocket')
    clear_intervals()
    start_websocket().then(onSuccess, onError)
  } else {
    console.log('Using polling')
    await stop_websocket()
    const new_value = ((await get_polling_interval()) || polling_interval)
    if (new_value !== polling_interval || intervals.length === 0) {
      polling_interval = new_value
      recreate_intervals()
    }
  }
}

init_background().then(onSuccess, onError)


// A placeholder for OnSuccess in .then
function onSuccess(message) {
  // console.log(`Background::Send OK: ${JSON.stringify(message)}`);
}

// A placeholder for OnError in .then
function onError(error) {
  console.error(`Background::Promise error: ${error}`)
}

// A placeholder for OnError in .then
function onErrorWithLog(error) {
  console.error(`Background::Promise error: ${error}`)
}

// Popup button handler
// Fetches the data from Spotify using the creds extracted earlier
chrome.runtime.onMessage.addListener(async (request, sender, sendResponse) => {
  console.log(`Popup message received: ${JSON.stringify(request)}, ${JSON.stringify(sender)}`)
  return true
  // chrome.runtime.sendMessage("Missing how many tracks to add param. It's a bug.").then(onSuccess, onError);
})